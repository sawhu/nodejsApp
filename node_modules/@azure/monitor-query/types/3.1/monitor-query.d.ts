import { CommonClientOptions } from '@azure/core-client';
import { OperationOptions } from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { TokenCredential } from '@azure/core-auth';
/** Defines values for AggregationType. */
export declare type AggregationType = "None" | "Average" | "Count" | "Minimum" | "Maximum" | "Total";
/**
 * Aliases for some common ISO8601 durations.
 */
export declare const Durations: {
    /** Alias for ISO8601 value 'P7D' */
    readonly sevenDays: "P7D";
    /** Alias for ISO8601 value 'P3D' */
    readonly threeDays: "P3D";
    /** Alias for ISO8601 value 'P2D' */
    readonly twoDays: "P2D";
    /** Alias for ISO8601 value 'P1D' */
    readonly oneDay: "P1D";
    /** Alias for ISO8601 value 'PT1H' */
    readonly oneHour: "PT1H";
    /** Alias for ISO8601 value 'PT4H' */
    readonly fourHours: "PT4H";
    /** Alias for ISO8601 value 'PT24H' */
    readonly twentyFourHours: "PT24H";
    /** Alias for ISO8601 value 'PT48H' */
    readonly fortyEightHours: "PT48H";
    /**
     * @deprecated Alias name `fourtyEightHours` for ISO8601 value 'PT48H' is deprecated
     */
    readonly fourtyEightHours: "PT48H";
    /** Alias for ISO8601 value 'PT30M' */
    readonly thirtyMinutes: "PT30M";
    /** Alias for ISO8601 value 'PT5M' */
    readonly fiveMinutes: "PT5M";
};
/**
 * Options used when getting metric definitions.
 */
export declare interface ListMetricDefinitionsOptions extends OperationOptions {
    /** Metric namespace to query metric definitions for. */
    metricNamespace?: string;
}
/**
 * Options used when getting metric namespaces.
 */
export declare interface ListMetricNamespacesOptions extends OperationOptions {
    /** The ISO 8601 conform Date start time from which to query for metric namespaces. */
    startTime?: string;
}
/** A column in a table. */
export declare interface LogsColumn {
    /** The name of this column. */
    name?: string;
    /** The data type of this column.
     * Defines values for LogsColumnType.
     * {@link KnownLogsColumnType} can be used interchangeably with LogsColumnType,
     *  this enum contains the known values that the service supports.
     * ### Known values supported by the service
     * **bool**
     * **datetime**
     * **dynamic**
     * **int**
     * **long**
     * **real**
     * **string**
     * **guid**
     * **decimal**
     * **timespan**
     */
    type?: LogsColumnType;
}
/**
 * Defines values for LogsColumnType. \
 * {@link KnownLogsColumnType} can be used interchangeably with LogsColumnType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **bool** \
 * **datetime** \
 * **dynamic** \
 * **int** \
 * **long** \
 * **real** \
 * **string** \
 * **guid** \
 * **decimal** \
 * **timespan**
 */
export declare type LogsColumnType = string;
/** The code and message for an error. */
export declare interface LogsErrorInfo extends Error {
    /** A machine readable error code. */
    code: string;
}
/** Configurable HTTP request settings for the Logs query batch operation. */
export declare interface LogsQueryBatchOptions extends OperationOptions {
}
/** Results for a batch query. Each result in the array is either of type
 *  {@link LogsQueryError} or {@link LogsQueryPartialResult} or {@link LogsQuerySuccessfulResult}
 */
export declare type LogsQueryBatchResult = Array<LogsQueryPartialResult | LogsQuerySuccessfulResult | LogsQueryError>;
/**
 * Client for Azure Log Analytics
 */
export declare class LogsQueryClient {
    private _logAnalytics;
    /**
     * Construct a LogsClient that can be used to query logs using the Log Analytics Query language.
     *
     * @param tokenCredential - A token credential.
     * @param options - Options for the LogsClient.
     */
    constructor(tokenCredential: TokenCredential, options?: LogsQueryClientOptions);
    /**
     * Queries logs in a Log Analytics Workspace.
     *
     * @param workspaceId - The 'Workspace Id' for the Log Analytics Workspace
     * @param query - A Kusto query.
     * @param timespan - The timespan over which to query data. This is an ISO8601 time period value. This timespan is applied in addition to any that are specified in the query expression.
     *  Some common durations can be found in the `Durations` object.
     * @param options - Options to adjust various aspects of the request.
     * @returns The result of the query.
     */
    queryWorkspace(workspaceId: string, query: string, timespan: QueryTimeInterval, options?: LogsQueryOptions): Promise<LogsQueryResult>;
    /**
     * Query Logs with multiple queries, in a batch.
     * @param batch - A batch of Kusto queries to execute. Each query can be configured to run against separate workspaces.
     * @param options - Options for querying logs in a batch.
     * @returns The Logs query results for all the queries.
     */
    queryBatch(batch: QueryBatch[], options?: LogsQueryBatchOptions): Promise<LogsQueryBatchResult>;
    /**
     * Executes a Kusto query on an Azure resource
     *
     * @param resourceId - The identifier of the resource. The expected format is
     '/subscriptions/<sid>/resourceGroups/<rg>/providers/<providerName>/<resourceType>/<resourceName>'.
     * @param query - A Kusto query. Learn more about the `Kusto query syntax <https://docs.microsoft.com/azure/data-explorer/kusto/query/>`.
     * @param timespan - The timespan over which to query data. This is an ISO8601 time period value. This timespan is applied in addition to any that are specified in the query expression.
     *  Some common durations can be found in the {@link Durations} object.
     * @param options - Options to adjust various aspects of the request.
     * @returns Returns all the Azure Monitor logs matching the given Kusto query for an Azure resource.
     */
    queryResource(resourceId: string, query: string, timespan: QueryTimeInterval, options?: LogsQueryOptions): Promise<LogsQueryResult>;
}
/**
 * Options for the LogsQueryClient.
 */
export declare interface LogsQueryClientOptions extends CommonClientOptions {
    /**
     * The host to connect to.
     */
    endpoint?: string;
}
/** Result type for Failure Scenario representing error for logs queryWorkspace and queryBatch operations. */
export declare interface LogsQueryError extends Error {
    /** A machine readable error code. */
    code: string;
    /** Indicates that the query failed */
    status: LogsQueryResultStatus.Failure;
}
/**
 * Options for querying logs.
 */
export declare interface LogsQueryOptions extends OperationOptions {
    /**
     * A list of workspaces that are included in the query, except for the one set as the `workspaceId` parameter
     * These may consist of the following identifier formats:
     * - Qualified workspace names
     * - Workspace IDs
     * - Azure resource IDs
     */
    additionalWorkspaces?: string[];
    /**
     * The maximum amount of time the server will spend processing the query.
     * Default: 180 seconds (3 minutes), maximum allowed is 600 seconds (10 minutes)
     */
    serverTimeoutInSeconds?: number;
    /**
     * Results will also include statistics about the query.
     */
    includeQueryStatistics?: boolean;
    /**
     * Results will also include visualization information, in JSON format.
     */
    includeVisualization?: boolean;
}
/** Result type for Partial Failure Scenario for logs queryWorkspace and queryBatch operations. */
export declare interface LogsQueryPartialResult {
    /** Populated results from the query. */
    partialTables: LogsTable[];
    /** error information for partial errors or failed queries */
    partialError: LogsErrorInfo;
    /** Indicates that the query partially failed.*/
    status: LogsQueryResultStatus.PartialFailure;
    /** Statistics represented in JSON format. */
    statistics?: Record<string, unknown>;
    /** Visualization data in JSON format. */
    visualization?: Record<string, unknown>;
}
/**
 * Tables and statistic results from a logs query.
 */
export declare type LogsQueryResult = LogsQuerySuccessfulResult | LogsQueryPartialResult;
/** Indicates if a query succeeded or failed or partially failed.
 * Represented by PartialFailure" | "Success" | "Failure".
 */
export declare enum LogsQueryResultStatus {
    /** Represents Partial Failure scenario where partial data and errors of type {@link LogsQueryPartialResult} is returned for query */
    PartialFailure = "PartialFailure",
    /** Represents Failure scenario where only error of type {@link LogsQueryError} is returned for query */
    Failure = "Failure",
    /** Represents Success scenario where all data of type {@link LogsQuerySuccessfulResult} is returned for query */
    Success = "Success"
}
/** Result type for Success Scenario for logs query workspace and query batch operations. */
export declare interface LogsQuerySuccessfulResult {
    /** Populated results from the query. */
    tables: LogsTable[];
    /** Indicates that the query succeeded */
    status: LogsQueryResultStatus.Success;
    /** Statistics represented in JSON format. */
    statistics?: Record<string, unknown>;
    /** Visualization data in JSON format. */
    visualization?: Record<string, unknown>;
}
/** Contains the columns and rows for one table in a query response. */
export declare interface LogsTable {
    /** The name of the table. */
    name: string;
    /** The list of columns in this table. */
    columnDescriptors: LogsColumn[];
    /** The two dimensional array of results from this query indexed by row and column. */
    rows: (Date | string | number | Record<string, unknown> | boolean)[][];
}
/** Represents a metric metadata value. */
export declare interface MetadataValue {
    /** the name of the metadata. */
    name?: string;
    /** the value of the metadata. */
    value?: string;
}
/** The result data of a query. */
export declare interface Metric {
    /** the metric Id. */
    id: string;
    /** the resource type of the metric resource. */
    type: string;
    /** the name of the metric */
    name: string;
    /** Detailed description of this metric. */
    description?: string;
    /** 'Success' or the error details on query failures for this metric. */
    errorCode?: string;
    /** Error message encountered querying this specific metric. */
    errorMessage?: string;
    /** the unit of the metric. */
    unit: MetricUnit;
    /** the time series returned when a data query is performed. */
    timeseries: TimeSeriesElement[];
}
/** Metric availability specifies the time grain (aggregation interval or frequency) and the retention period for that time grain. */
export declare interface MetricAvailability {
    /** the time grain specifies the aggregation interval for the metric. Expressed as a duration 'PT1M', 'P1D', etc. */
    granularity?: string;
    /** the retention period for the metric at the specified granularity.  Expressed as a duration 'PT1M', 'P1D', etc. */
    retention?: string;
}
/**
 * Defines values for MetricClass. \
 * {@link KnownMetricClass} can be used interchangeably with MetricClass,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Availability** \
 * **Transactions** \
 * **Errors** \
 * **Latency** \
 * **Saturation**
 */
export declare type MetricClass = string;
/** Metric definition class specifies the metadata for a metric. */
export declare interface MetricDefinition {
    /** Flag to indicate whether the dimension is required. */
    isDimensionRequired?: boolean;
    /** the resource identifier of the resource that emitted the metric. */
    resourceId?: string;
    /** the namespace the metric belongs to. */
    namespace?: string;
    /** the name and the display name of the metric, i.e. it is a localizable string. */
    name?: string;
    /** Detailed description of this metric. */
    description?: string;
    /** Custom category name for this metric. */
    category?: string;
    /** The class of the metric. */
    metricClass?: MetricClass;
    /** The unit of the metric. */
    unit?: MetricUnit;
    /** the primary aggregation type value defining how to use the values for display. */
    primaryAggregationType?: AggregationType;
    /** the collection of what aggregation types are supported. */
    supportedAggregationTypes?: AggregationType[];
    /** the collection of what aggregation intervals are available to be queried. */
    metricAvailabilities?: MetricAvailability[];
    /** the resource identifier of the metric definition. */
    id?: string;
    /** the name and the display name of the dimension, i.e. it is a localizable string. */
    dimensions?: string[];
}
/** Metric namespace class specifies the metadata for a metric namespace. */
export declare interface MetricNamespace {
    /** The ID of the metric namespace. */
    id?: string;
    /** The type of the namespace. */
    type?: string;
    /** The escaped name of the namespace. */
    name?: string;
    /** Kind of namespace */
    classification?: NamespaceClassification;
    /** The metric namespace name. */
    metricNamespaceName?: string;
}
/**
 * Options for the MetricsQueryClient.
 */
export declare interface MetricsClientOptions extends CommonClientOptions {
    /** Overrides client endpoint. */
    endpoint?: string;
}
/**
 * A client that can query metrics, get metric definitions and get metric namespaces.
 */
export declare class MetricsQueryClient {
    private _metricsClient;
    private _definitionsClient;
    private _namespacesClient;
    /**
     * Creates a MetricsQueryClient.
     * @param tokenCredential - A TokenCredential that has rights to query metrics on resources.
     * @param options - Options for the client like controlling request retries.
     */
    constructor(tokenCredential: TokenCredential, options?: MetricsClientOptions);
    /**
     * Query metrics, given a resource URI
     * @param resourceUri - The resource URI to query.
     * @param metricNames - The names of the metrics to retrieve.
     * @param options - Options for querying metrics.
     * @returns A response containing metrics.
     */
    queryResource(resourceUri: string, metricNames: string[], options?: MetricsQueryOptions): Promise<MetricsQueryResult>;
    /**
     * List alert segments for Metric Definitions
     */
    private listSegmentOfMetricDefinitions;
    /**
     * List items for Metric Definitions
     */
    private listItemsOfMetricDefinitions;
    /**
     *   /**
     *
     * Returns an async iterable iterator to list metric definitions.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * const metricsQueryClient = new MetricsQueryClient(tokenCredential);
     * const metricDefinitions = client.listMetricDefinitions(resourceUri, options);
     * let i = 1;
     * for await (const metricDefinition of metricDefinitions) {
     *   console.log(`metricDefinition ${i++}:`);
     *   console.log(metricDefinition);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let iter = client.listMetricDefinitions(resourceUri, options);
     * let result = await iter.next();
     * while (!result.done) {
     *   console.log(` metricDefinitions - ${result.value.id}, ${result.value.name}`);
     *   result = await iter.next();
     * }
     * ```
     *
     * Get a list of metric definitions, given a resource URI.
     * @param resourceUri - The resource URI to get metric definitions for.
     * @param options - Options for getting metric definitions.
     * @returns Metric definitions for a given resource URI.
     */
    listMetricDefinitions(resourceUri: string, options?: ListMetricDefinitionsOptions): PagedAsyncIterableIterator<MetricDefinition>;
    /**
     * List alert segments for Metric Namespaces
     */
    private listSegmentOfMetricNamespaces;
    /**
     * List items for Metric Namespaces
     */
    private listItemsOfMetricNamespaces;
    /**
     *
     * Returns an async iterable iterator to list metric namespaces.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * const metricsQueryClient = new MetricsQueryClient(tokenCredential);
     * const metricNamespaces = client.listMetricNamespaces(resourceUri, options);
     * let i = 1;
     * for await (const metricNamespace of metricNamespaces) {
     *   console.log(`metricNamespace ${i++}:`);
     *   console.log(metricNamespace);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let iter = client.listMetricNamespaces(resourceUri, options);
     * let result = await iter.next();
     * while (!result.done) {
     *   console.log(` metricNamespace - ${result.value.id}, ${result.value.name}`);
     *   result = await iter.next();
     * }
     * ```
     * Get a list of metric namespaces, given a resource URI.
     * @param resourceUri - The resource URI to get metric namespaces for.
     * @param options - Options for getting metric namespaces.
     * @returns Metric namespaces for a given resource URI.
     */
    listMetricNamespaces(resourceUri: string, options?: ListMetricNamespacesOptions): PagedAsyncIterableIterator<MetricNamespace>;
}
/**
 * Options used when querying metrics.
 */
export declare interface MetricsQueryOptions extends OperationOptions {
    /** The interval (i.e. timegrain) of the query. {@link Durations} helper contains aliases for some common ISO8601 durations.
     * This is an ISO8601 duration value in the format P[n]Y[n]M[n]DT[n]H[n]M[n]S
     *  where P is the duration designator (for period) placed at the start of the duration representation.
     *   Y is the year designator that follows the value for the number of years.
     *   M is the month designator that follows the value for the number of months.
     *   W is the week designator that follows the value for the number of weeks.
     *   D is the day designator that follows the value for the number of days.
     *   T is the time designator that precedes the time components of the representation.
     *   H is the hour designator that follows the value for the number of hours.
     *   M is the minute designator that follows the value for the number of minutes.
     *   S is the second designator that follows the value for the number of seconds.
     */
    granularity?: string;
    /** The enclosing timespan for metrics. */
    timespan?: QueryTimeInterval;
    /** The list of aggregation types (comma separated) to retrieve. */
    aggregations?: AggregationType[];
    /**
     * The maximum number of records to retrieve.
     * Valid only if $filter is specified.
     * Defaults to 10.
     */
    top?: number;
    /**
     * The aggregation to use for sorting results and the direction of the sort.
     * Only one order can be specified.
     * Examples: sum asc.
     */
    orderBy?: string;
    /** The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’ or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A = a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**. */
    filter?: string;
    /** Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's description for details. */
    resultType?: ResultType;
    /** Metric namespace to query metric definitions for. */
    metricNamespace?: string;
}
/**
 * Metrics, including additional information like cost, the resourceRegion, etc...
 */
export declare interface MetricsQueryResult {
    /** The integer value representing the cost of the query, for data case. */
    cost?: number;
    /** The timespan for which the data was retrieved. Its value consists of two datetimes concatenated, separated by '/'.  This may be adjusted in the future and returned back from what was originally requested. */
    timespan: QueryTimeInterval;
    /** The interval (window size) for which the metric data was returned in.  This may be adjusted in the future and returned back from what was originally requested.  This is not present if a metadata request was made. */
    granularity?: string;
    /** The namespace of the metrics been queried */
    namespace?: string;
    /** The region of the resource been queried for metrics. */
    resourceRegion?: string;
    /** the value of the collection. */
    metrics: Metric[];
    /** convenience method to get metric by metric name */
    getMetricByName(metricName: string): Metric | undefined;
}
/**
 * Defines values for MetricUnit. \
 * {@link KnownMetricUnit} can be used interchangeably with MetricUnit,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Count** \
 * **Bytes** \
 * **Seconds** \
 * **CountPerSecond** \
 * **BytesPerSecond** \
 * **Percent** \
 * **MilliSeconds** \
 * **ByteSeconds** \
 * **Unspecified** \
 * **Cores** \
 * **MilliCores** \
 * **NanoCores** \
 * **BitsPerSecond**
 */
export declare type MetricUnit = string;
/** Represents a metric value. */
export declare interface MetricValue {
    /** the timestamp for the metric value in ISO 8601 format. */
    timeStamp: Date;
    /** the average value in the time range. */
    average?: number;
    /** the least value in the time range. */
    minimum?: number;
    /** the greatest value in the time range. */
    maximum?: number;
    /** the sum of all of the values in the time range. */
    total?: number;
    /** the number of samples in the time range. Can be used to determine the number of values that contributed to the average value. */
    count?: number;
}
/**
 * Defines values for NamespaceClassification. \
 * {@link KnownNamespaceClassification} can be used interchangeably with NamespaceClassification,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Platform** \
 * **Custom** \
 * **Qos**
 */
export declare type NamespaceClassification = string;
/** The Kusto query. For more information about Kusto, see [Kusto query overview](https://docs.microsoft.com/azure/data-explorer/kusto/query). */
export declare interface QueryBatch {
    /** The workspace for this query. */
    workspaceId: string;
    /** The query to execute. */
    query: string;
    /** The timespan over which to query data. This timespan is applied in addition to any that are specified in the query expression. */
    timespan: QueryTimeInterval;
    /**
     * A list of workspaces that are included in the query, except for the one set as the `workspaceId` parameter
     * These may consist of the following identifier formats:
     * - Qualified workspace names
     * - Workspace IDs
     * - Azure resource IDs
     */
    additionalWorkspaces?: string[];
    /**
     * The maximum amount of time the server will spend processing the query.
     * Default: 180 seconds (3 minutes), maximum allowed is 600 seconds (10 minutes)
     */
    serverTimeoutInSeconds?: number;
    /**
     * Results will also include statistics about the query.
     */
    includeQueryStatistics?: boolean;
    /**
     * Results will also include visualization information, in JSON format.
     */
    includeVisualization?: boolean;
}
/**
 * Time Interval type for specifying timespan for querying logs and metrics.
 * A time interval is the intervening time between two time points.
 * The amount of intervening time is expressed by a duration The two time points (start and end) are expressed by either a combined date and time representation
 * or just a date representation.There are four ways to express a time interval:
 * - duration
 * - start time, end time
 * - start time, duration
 * - duration, end time
 */
export declare type QueryTimeInterval = {
    /**
     * Start time for time interval
     */
    startTime: Date;
    /**
     * End time for time interval
     */
    endTime: Date;
} | {
    /**
     * Start time for time interval
     */
    startTime: Date;
    /**
     * The duration from the start time. {@link Durations} helper contains aliases for some common ISO8601 durations.
     * The duration is an ISO8601 duration value in the format P[n]Y[n]M[n]DT[n]H[n]M[n]S
     * where  P is the duration designator (for period) placed at the start of the duration representation.
     *   Y is the year designator that follows the value for the number of years.
     *   M is the month designator that follows the value for the number of months.
     *   W is the week designator that follows the value for the number of weeks.
     *   D is the day designator that follows the value for the number of days.
     *   T is the time designator that precedes the time components of the representation.
     *   H is the hour designator that follows the value for the number of hours.
     *   M is the minute designator that follows the value for the number of minutes.
     *   S is the second designator that follows the value for the number of seconds.
     */
    duration: string;
} | {
    /**
     * The duration until the end time. {@link Durations} helper contains aliases for some common ISO8601 durations.
     * The duration is an ISO8601 duration value in the format P[n]Y[n]M[n]DT[n]H[n]M[n]S
     * where  P is the duration designator (for period) placed at the start of the duration representation.
     *   Y is the year designator that follows the value for the number of years.
     *   M is the month designator that follows the value for the number of months.
     *   W is the week designator that follows the value for the number of weeks.
     *   D is the day designator that follows the value for the number of days.
     *   T is the time designator that precedes the time components of the representation.
     *   H is the hour designator that follows the value for the number of hours.
     *   M is the minute designator that follows the value for the number of minutes.
     *   S is the second designator that follows the value for the number of seconds.
     */
    duration: string;
    /**
     * end time for interval
     */
    endTime: Date;
} | {
    /**
     * The duration of a time span that ends at the time the operation is processed, e.g. events from the last 5 hours.
     * {@link Durations} helper contains aliases for some common ISO8601 durations.
     * The duration is an ISO8601 time period value in the format P[n]Y[n]M[n]DT[n]H[n]M[n]S
     * where  P is the duration designator (for period) placed at the start of the duration representation.
     *   Y is the year designator that follows the value for the number of years.
     *   M is the month designator that follows the value for the number of months.
     *   W is the week designator that follows the value for the number of weeks.
     *   D is the day designator that follows the value for the number of days.
     *   T is the time designator that precedes the time components of the representation.
     *   H is the hour designator that follows the value for the number of hours.
     *   M is the minute designator that follows the value for the number of minutes.
     *   S is the second designator that follows the value for the number of seconds.
     */
    duration: string;
};
/** Defines values for ResultType. */
export declare type ResultType = "Data" | "Metadata";
/** A time series result type. The discriminator value is always TimeSeries in this case. */
export declare interface TimeSeriesElement {
    /** the metadata values returned if $filter was specified in the call. */
    metadataValues?: MetadataValue[];
    /** An array of data points representing the metric values.  This is only returned if a result type of data is specified. */
    data?: MetricValue[];
}
export {};

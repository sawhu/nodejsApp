'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var coreTracing = require('@azure/core-tracing');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const QueryResults = {
    type: {
        name: "Composite",
        className: "QueryResults",
        modelProperties: {
            tables: {
                serializedName: "tables",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Table"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            render: {
                serializedName: "render",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorInfo"
                }
            }
        }
    }
};
const Table = {
    type: {
        name: "Composite",
        className: "Table",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            columns: {
                serializedName: "columns",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Column"
                        }
                    }
                }
            },
            rows: {
                serializedName: "rows",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Dictionary",
                                    value: { type: { name: "any" } }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
const Column = {
    type: {
        name: "Composite",
        className: "Column",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorInfo = {
    type: {
        name: "Composite",
        className: "ErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorInfo"
                }
            },
            additionalProperties: {
                serializedName: "additionalProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            additionalProperties: {
                serializedName: "additionalProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ErrorResponse$3 = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorInfo"
                }
            }
        }
    }
};
const QueryBody = {
    type: {
        name: "Composite",
        className: "QueryBody",
        modelProperties: {
            query: {
                serializedName: "query",
                required: true,
                type: {
                    name: "String"
                }
            },
            timespan: {
                serializedName: "timespan",
                type: {
                    name: "String"
                }
            },
            workspaces: {
                serializedName: "workspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataResults = {
    type: {
        name: "Composite",
        className: "MetadataResults",
        modelProperties: {
            categories: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataCategory"
                        }
                    }
                }
            },
            resourceTypes: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "resourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataResourceType"
                        }
                    }
                }
            },
            solutions: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "solutions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataSolution"
                        }
                    }
                }
            },
            tables: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataTable"
                        }
                    }
                }
            },
            functions: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataFunction"
                        }
                    }
                }
            },
            queries: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "queries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataQuery"
                        }
                    }
                }
            },
            applications: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "applications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataApplication"
                        }
                    }
                }
            },
            workspaces: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "workspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataWorkspace"
                        }
                    }
                }
            },
            resources: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "any"
                        }
                    }
                }
            },
            permissions: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "permissions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataPermissions"
                        }
                    }
                }
            }
        }
    }
};
const MetadataCategory = {
    type: {
        name: "Composite",
        className: "MetadataCategory",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            related: {
                serializedName: "related",
                type: {
                    name: "Composite",
                    className: "MetadataCategoryRelated"
                }
            }
        }
    }
};
const MetadataCategoryRelated = {
    type: {
        name: "Composite",
        className: "MetadataCategoryRelated",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resourceTypes: {
                serializedName: "resourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            queries: {
                serializedName: "queries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            solutions: {
                serializedName: "solutions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataResourceType = {
    type: {
        name: "Composite",
        className: "MetadataResourceType",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            labels: {
                serializedName: "labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            related: {
                serializedName: "related",
                type: {
                    name: "Composite",
                    className: "MetadataResourceTypeRelated"
                }
            }
        }
    }
};
const MetadataResourceTypeRelated = {
    type: {
        name: "Composite",
        className: "MetadataResourceTypeRelated",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            queries: {
                serializedName: "queries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            workspaces: {
                serializedName: "workspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataSolution = {
    type: {
        name: "Composite",
        className: "MetadataSolution",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            related: {
                serializedName: "related",
                type: {
                    name: "Composite",
                    className: "MetadataSolutionRelated"
                }
            }
        }
    }
};
const MetadataSolutionRelated = {
    type: {
        name: "Composite",
        className: "MetadataSolutionRelated",
        modelProperties: {
            tables: {
                serializedName: "tables",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            queries: {
                serializedName: "queries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            workspaces: {
                serializedName: "workspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataTable = {
    type: {
        name: "Composite",
        className: "MetadataTable",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            timespanColumn: {
                serializedName: "timespanColumn",
                type: {
                    name: "String"
                }
            },
            labels: {
                serializedName: "labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            columns: {
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataTableColumnsItem"
                        }
                    }
                }
            },
            related: {
                serializedName: "related",
                type: {
                    name: "Composite",
                    className: "MetadataTableRelated"
                }
            }
        }
    }
};
const MetadataTableColumnsItem = {
    type: {
        name: "Composite",
        className: "MetadataTableColumnsItem",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            isPreferredFacet: {
                serializedName: "isPreferredFacet",
                type: {
                    name: "Boolean"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const MetadataTableRelated = {
    type: {
        name: "Composite",
        className: "MetadataTableRelated",
        modelProperties: {
            categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            solutions: {
                serializedName: "solutions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resourceTypes: {
                serializedName: "resourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            workspaces: {
                serializedName: "workspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            queries: {
                serializedName: "queries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataFunction = {
    type: {
        name: "Composite",
        className: "MetadataFunction",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            body: {
                serializedName: "body",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            related: {
                serializedName: "related",
                type: {
                    name: "Composite",
                    className: "MetadataFunctionRelated"
                }
            }
        }
    }
};
const MetadataFunctionRelated = {
    type: {
        name: "Composite",
        className: "MetadataFunctionRelated",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            solutions: {
                serializedName: "solutions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resourceTypes: {
                serializedName: "resourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            workspaces: {
                serializedName: "workspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataQuery = {
    type: {
        name: "Composite",
        className: "MetadataQuery",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            body: {
                serializedName: "body",
                required: true,
                type: {
                    name: "String"
                }
            },
            labels: {
                serializedName: "labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            related: {
                serializedName: "related",
                type: {
                    name: "Composite",
                    className: "MetadataQueryRelated"
                }
            }
        }
    }
};
const MetadataQueryRelated = {
    type: {
        name: "Composite",
        className: "MetadataQueryRelated",
        modelProperties: {
            categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            solutions: {
                serializedName: "solutions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resourceTypes: {
                serializedName: "resourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataApplication = {
    type: {
        name: "Composite",
        className: "MetadataApplication",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            region: {
                serializedName: "region",
                required: true,
                type: {
                    name: "String"
                }
            },
            related: {
                serializedName: "related",
                type: {
                    name: "Composite",
                    className: "MetadataApplicationRelated"
                }
            }
        }
    }
};
const MetadataApplicationRelated = {
    type: {
        name: "Composite",
        className: "MetadataApplicationRelated",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataWorkspace = {
    type: {
        name: "Composite",
        className: "MetadataWorkspace",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            region: {
                serializedName: "region",
                required: true,
                type: {
                    name: "String"
                }
            },
            related: {
                serializedName: "related",
                type: {
                    name: "Composite",
                    className: "MetadataWorkspaceRelated"
                }
            }
        }
    }
};
const MetadataWorkspaceRelated = {
    type: {
        name: "Composite",
        className: "MetadataWorkspaceRelated",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            solutions: {
                serializedName: "solutions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resourceTypes: {
                serializedName: "resourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataPermissions = {
    type: {
        name: "Composite",
        className: "MetadataPermissions",
        modelProperties: {
            workspaces: {
                serializedName: "workspaces",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataPermissionsWorkspacesItem"
                        }
                    }
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataPermissionsResourcesItem"
                        }
                    }
                }
            },
            applications: {
                serializedName: "applications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataPermissionsApplicationsItem"
                        }
                    }
                }
            }
        }
    }
};
const MetadataPermissionsWorkspacesItem = {
    type: {
        name: "Composite",
        className: "MetadataPermissionsWorkspacesItem",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            denyTables: {
                serializedName: "denyTables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataPermissionsResourcesItem = {
    type: {
        name: "Composite",
        className: "MetadataPermissionsResourcesItem",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            denyTables: {
                serializedName: "denyTables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetadataPermissionsApplicationsItem = {
    type: {
        name: "Composite",
        className: "MetadataPermissionsApplicationsItem",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchRequest = {
    type: {
        name: "Composite",
        className: "BatchRequest",
        modelProperties: {
            requests: {
                serializedName: "requests",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BatchQueryRequest"
                        }
                    }
                }
            }
        }
    }
};
const BatchQueryRequest = {
    type: {
        name: "Composite",
        className: "BatchQueryRequest",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            headers: {
                serializedName: "headers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            body: {
                serializedName: "body",
                type: {
                    name: "Composite",
                    className: "QueryBody"
                }
            },
            path: {
                defaultValue: "/query",
                isConstant: true,
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            method: {
                defaultValue: "POST",
                isConstant: true,
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            workspace: {
                serializedName: "workspace",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchResponse = {
    type: {
        name: "Composite",
        className: "BatchResponse",
        modelProperties: {
            responses: {
                serializedName: "responses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BatchQueryResponse"
                        }
                    }
                }
            }
        }
    }
};
const BatchQueryResponse = {
    type: {
        name: "Composite",
        className: "BatchQueryResponse",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Number"
                }
            },
            body: {
                serializedName: "body",
                type: {
                    name: "Composite",
                    className: "BatchQueryResults"
                }
            },
            headers: {
                serializedName: "headers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const BatchQueryResults = {
    type: {
        name: "Composite",
        className: "BatchQueryResults",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Table"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            render: {
                serializedName: "render",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorInfo"
                }
            }
        }
    }
};

var Mappers$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    QueryResults: QueryResults,
    Table: Table,
    Column: Column,
    ErrorInfo: ErrorInfo,
    ErrorDetail: ErrorDetail,
    ErrorResponse: ErrorResponse$3,
    QueryBody: QueryBody,
    MetadataResults: MetadataResults,
    MetadataCategory: MetadataCategory,
    MetadataCategoryRelated: MetadataCategoryRelated,
    MetadataResourceType: MetadataResourceType,
    MetadataResourceTypeRelated: MetadataResourceTypeRelated,
    MetadataSolution: MetadataSolution,
    MetadataSolutionRelated: MetadataSolutionRelated,
    MetadataTable: MetadataTable,
    MetadataTableColumnsItem: MetadataTableColumnsItem,
    MetadataTableRelated: MetadataTableRelated,
    MetadataFunction: MetadataFunction,
    MetadataFunctionRelated: MetadataFunctionRelated,
    MetadataQuery: MetadataQuery,
    MetadataQueryRelated: MetadataQueryRelated,
    MetadataApplication: MetadataApplication,
    MetadataApplicationRelated: MetadataApplicationRelated,
    MetadataWorkspace: MetadataWorkspace,
    MetadataWorkspaceRelated: MetadataWorkspaceRelated,
    MetadataPermissions: MetadataPermissions,
    MetadataPermissionsWorkspacesItem: MetadataPermissionsWorkspacesItem,
    MetadataPermissionsResourcesItem: MetadataPermissionsResourcesItem,
    MetadataPermissionsApplicationsItem: MetadataPermissionsApplicationsItem,
    BatchRequest: BatchRequest,
    BatchQueryRequest: BatchQueryRequest,
    BatchResponse: BatchResponse,
    BatchQueryResponse: BatchQueryResponse,
    BatchQueryResults: BatchQueryResults
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept$3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host$3 = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const workspaceId = {
    parameterPath: "workspaceId",
    mapper: {
        serializedName: "workspaceId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const query = {
    parameterPath: "query",
    mapper: {
        serializedName: "query",
        required: true,
        type: {
            name: "String"
        }
    }
};
const timespan$1 = {
    parameterPath: ["options", "timespan"],
    mapper: {
        serializedName: "timespan",
        type: {
            name: "TimeSpan"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: QueryBody
};
const prefer = {
    parameterPath: ["options", "prefer"],
    mapper: {
        serializedName: "Prefer",
        type: {
            name: "String"
        }
    }
};
const resourceId = {
    parameterPath: "resourceId",
    mapper: {
        serializedName: "resourceId",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const body1 = {
    parameterPath: "body",
    mapper: BatchRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Query operations. */
class QueryImpl {
    /**
     * Initialize a new instance of the class Query class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Executes an Analytics query for data
     * @param workspaceId ID of the workspace. This is Workspace ID from the Properties blade in the Azure
     *                    portal.
     * @param query The Analytics query. Learn more about the [Analytics query
     *              syntax](https://azure.microsoft.com/documentation/articles/app-insights-analytics-reference/)
     * @param options The options parameters.
     */
    get(workspaceId, query, options) {
        return this.client.sendOperationRequest({ workspaceId, query, options }, getOperationSpec$1);
    }
    /**
     * Executes an Analytics query for data.
     * [Here](https://dev.loganalytics.io/documentation/Using-the-API) is an example for using POST with an
     * Analytics query.
     * @param workspaceId ID of the workspace. This is Workspace ID from the Properties blade in the Azure
     *                    portal.
     * @param body The Analytics query. Learn more about the [Analytics query
     *             syntax](https://azure.microsoft.com/documentation/articles/app-insights-analytics-reference/)
     * @param options The options parameters.
     */
    execute(workspaceId, body, options) {
        return this.client.sendOperationRequest({ workspaceId, body, options }, executeOperationSpec);
    }
    /**
     * Executes an Analytics query for data in the context of a resource.
     * [Here](https://docs.microsoft.com/azure/azure-monitor/logs/api/azure-resource-queries) is an example
     * for using POST with an Analytics query.
     * @param resourceId The identifier of the resource.
     * @param query The Analytics query. Learn more about the [Analytics query
     *              syntax](https://azure.microsoft.com/documentation/articles/app-insights-analytics-reference/)
     * @param options The options parameters.
     */
    resourceGet(resourceId, query, options) {
        return this.client.sendOperationRequest({ resourceId, query, options }, resourceGetOperationSpec);
    }
    /**
     * Executes an Analytics query for data in the context of a resource.
     * [Here](https://docs.microsoft.com/azure/azure-monitor/logs/api/azure-resource-queries) is an example
     * for using POST with an Analytics query.
     * @param resourceId The identifier of the resource.
     * @param body The Analytics query. Learn more about the [Analytics query
     *             syntax](https://azure.microsoft.com/documentation/articles/app-insights-analytics-reference/)
     * @param options The options parameters.
     */
    resourceExecute(resourceId, body, options) {
        return this.client.sendOperationRequest({ resourceId, body, options }, resourceExecuteOperationSpec);
    }
    /**
     * Executes a batch of Analytics queries for data.
     * [Here](https://dev.loganalytics.io/documentation/Using-the-API) is an example for using POST with an
     * Analytics query.
     * @param body The batch request body
     * @param options The options parameters.
     */
    batch(body, options) {
        return this.client.sendOperationRequest({ body, options }, batchOperationSpec);
    }
    /**
     * Executes an Analytics query for data in the context of a resource.
     * [Here](https://docs.microsoft.com/azure/azure-monitor/logs/api/azure-resource-queries) is an example
     * for using POST with an Analytics query.
     * @param resourceId The identifier of the resource.
     * @param query The Analytics query. Learn more about the [Analytics query
     *              syntax](https://azure.microsoft.com/documentation/articles/app-insights-analytics-reference/)
     * @param options The options parameters.
     */
    resourceGetXms(resourceId, query, options) {
        return this.client.sendOperationRequest({ resourceId, query, options }, resourceGetXmsOperationSpec);
    }
    /**
     * Executes an Analytics query for data in the context of a resource.
     * [Here](https://docs.microsoft.com/azure/azure-monitor/logs/api/azure-resource-queries) is an example
     * for using POST with an Analytics query.
     * @param resourceId The identifier of the resource.
     * @param body The Analytics query. Learn more about the [Analytics query
     *             syntax](https://azure.microsoft.com/documentation/articles/app-insights-analytics-reference/)
     * @param options The options parameters.
     */
    resourceExecuteXms(resourceId, body, options) {
        return this.client.sendOperationRequest({ resourceId, body, options }, resourceExecuteXmsOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers$3, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/workspaces/{workspaceId}/query",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QueryResults
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    queryParameters: [query, timespan$1],
    urlParameters: [$host$3, workspaceId],
    headerParameters: [accept$3],
    serializer: serializer$4
};
const executeOperationSpec = {
    path: "/workspaces/{workspaceId}/query",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryResults
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    requestBody: body,
    urlParameters: [$host$3, workspaceId],
    headerParameters: [
        accept$3,
        contentType,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$4
};
const resourceGetOperationSpec = {
    path: "/{resourceId}/query",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QueryResults
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    queryParameters: [query, timespan$1],
    urlParameters: [$host$3, resourceId],
    headerParameters: [accept$3],
    serializer: serializer$4
};
const resourceExecuteOperationSpec = {
    path: "/{resourceId}/query",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryResults
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    requestBody: body,
    urlParameters: [$host$3, resourceId],
    headerParameters: [
        accept$3,
        contentType,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$4
};
const batchOperationSpec = {
    path: "/$batch",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BatchResponse
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    requestBody: body1,
    urlParameters: [$host$3],
    headerParameters: [accept$3, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const resourceGetXmsOperationSpec = {
    path: "/{resourceId}/query",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QueryResults
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    queryParameters: [query, timespan$1],
    urlParameters: [$host$3, resourceId],
    headerParameters: [accept$3],
    serializer: serializer$4
};
const resourceExecuteXmsOperationSpec = {
    path: "/{resourceId}/query",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryResults
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    requestBody: body,
    urlParameters: [$host$3, resourceId],
    headerParameters: [
        accept$3,
        contentType,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Metadata operations. */
class MetadataImpl {
    /**
     * Initialize a new instance of the class Metadata class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieve the metadata information for the workspace, including its schema, functions, workspace
     * info, categories etc.
     * @param workspaceId ID of the workspace. This is Workspace ID from the Properties blade in the Azure
     *                    portal.
     * @param options The options parameters.
     */
    get(workspaceId, options) {
        return this.client.sendOperationRequest({ workspaceId, options }, getOperationSpec);
    }
    /**
     * Retrieve the metadata information for the workspace, including its schema, functions, workspace
     * info, categories etc.
     * @param workspaceId ID of the workspace. This is Workspace ID from the Properties blade in the Azure
     *                    portal.
     * @param options The options parameters.
     */
    post(workspaceId, options) {
        return this.client.sendOperationRequest({ workspaceId, options }, postOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers$3, /* isXml */ false);
const getOperationSpec = {
    path: "/workspaces/{workspaceId}/metadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetadataResults
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    urlParameters: [$host$3, workspaceId],
    headerParameters: [accept$3],
    serializer: serializer$3
};
const postOperationSpec = {
    path: "/workspaces/{workspaceId}/metadata",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: MetadataResults
        },
        default: {
            bodyMapper: ErrorResponse$3
        }
    },
    urlParameters: [$host$3, workspaceId],
    headerParameters: [accept$3],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class AzureLogAnalyticsContext extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the AzureLogAnalyticsContext class.
     * @param options The parameter options
     */
    constructor(options) {
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-monitor-log-query/1.1.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://api.loganalytics.io/v1" });
        super(optionsWithDefaults);
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://api.loganalytics.io/v1";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class AzureLogAnalytics extends AzureLogAnalyticsContext {
    /**
     * Initializes a new instance of the AzureLogAnalytics class.
     * @param options The parameter options
     */
    constructor(options) {
        super(options);
        this.query = new QueryImpl(this);
        this.metadata = new MetadataImpl(this);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** Indicates if a query succeeded or failed or partially failed.
 * Represented by PartialFailure" | "Success" | "Failure".
 */
exports.LogsQueryResultStatus = void 0;
(function (LogsQueryResultStatus) {
    /** Represents Partial Failure scenario where partial data and errors of type {@link LogsQueryPartialResult} is returned for query */
    LogsQueryResultStatus["PartialFailure"] = "PartialFailure";
    /** Represents Failure scenario where only error of type {@link LogsQueryError} is returned for query */
    LogsQueryResultStatus["Failure"] = "Failure";
    /** Represents Success scenario where all data of type {@link LogsQuerySuccessfulResult} is returned for query */
    LogsQueryResultStatus["Success"] = "Success";
})(exports.LogsQueryResultStatus || (exports.LogsQueryResultStatus = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
function formatPreferHeader(args) {
    if (!args) {
        return undefined;
    }
    // https://datatracker.ietf.org/doc/html/rfc7240
    const pairs = [];
    if (args.serverTimeoutInSeconds != null) {
        pairs.push(`wait=${args.serverTimeoutInSeconds}`);
    }
    if (args.includeQueryStatistics) {
        pairs.push("include-statistics=true");
    }
    if (args.includeVisualization) {
        pairs.push("include-render=true");
    }
    if (pairs.length > 0) {
        return {
            Prefer: pairs.join(","),
        };
    }
    return undefined;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getMetricByName(metricName) {
    return this.metrics.find((it) => it.name === metricName);
}
function createMetricsQueryResult(metricsQueryResultData) {
    return Object.assign(Object.assign({}, metricsQueryResultData), { getMetricByName });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function convertTimespanToInterval(timespan) {
    if (isObjectWithProperties(timespan, ["startTime", "endTime", "duration"])) {
        throw new TypeError("Invalid Timespan - contains startTime, endTime, and duration.");
    }
    if (isObjectWithProperties(timespan, ["startTime", "endTime"])) {
        return `${timespan.startTime.toISOString()}/${timespan.endTime.toISOString()}`;
    }
    else if (isObjectWithProperties(timespan, ["startTime", "duration"])) {
        return `${timespan.startTime.toISOString()}/${timespan.duration}`;
    }
    else if (isObjectWithProperties(timespan, ["duration", "endTime"])) {
        return `${timespan.duration}/${timespan.endTime.toISOString()}`;
    }
    else if (isObjectWithProperties(timespan, ["duration"])) {
        return timespan.duration;
    }
    throw new TypeError("Invalid Timespan - no valid fields assigned.");
}
function convertIntervalToTimeIntervalObject(timespan) {
    if (timespan.includes("/")) {
        const intervalUnits = timespan.split("/");
        if (Date.parse(intervalUnits[0]) && Date.parse(intervalUnits[1])) {
            return { startTime: new Date(intervalUnits[0]), endTime: new Date(intervalUnits[1]) };
        }
        else if (Date.parse(intervalUnits[0]) && !Date.parse(intervalUnits[1])) {
            return { startTime: new Date(intervalUnits[0]), duration: intervalUnits[1] };
        }
        else if (!Date.parse(intervalUnits[0]) && Date.parse(intervalUnits[1])) {
            return { duration: intervalUnits[0], endTime: new Date(intervalUnits[1]) };
        }
        else {
            return { duration: timespan };
        }
    }
    else {
        return { duration: timespan };
    }
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * Note: The property may be inherited.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 * @internal
 */
function objectHasProperty(thing, property) {
    return typeof thing === "object" && property in thing;
}
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 * @internal
 */
function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified properties.
 * Note: The properties may be inherited.
 * @param thing - Anything.
 * @param properties - The name of the properties that should appear in the object.
 * @internal
 */
function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
        return false;
    }
    for (const property of properties) {
        if (!objectHasProperty(thing, property)) {
            return false;
        }
    }
    return true;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function convertRequestForQueryBatch(batch) {
    let id = 0;
    const requests = batch.map((query) => {
        const body = {
            workspaceId: query.workspaceId,
            query: query.query,
        };
        if (query["additionalWorkspaces"]) {
            body["workspaces"] = query["additionalWorkspaces"].map((x) => x);
        }
        if (query["timespan"]) {
            body["timespan"] = convertTimespanToInterval(query["timespan"]);
        }
        delete body["workspaceId"];
        delete body["includeQueryStatistics"];
        delete body["includeVisualization"];
        delete body["additionalWorkspaces"];
        delete body["serverTimeoutInSeconds"];
        const generatedRequest = {
            id: id.toString(),
            workspace: query.workspaceId,
            headers: formatPreferHeader(query),
            body,
        };
        ++id;
        return generatedRequest;
    });
    return {
        requests,
    };
}
/**
 * @internal
 */
function convertResponseForQueryBatch(generatedResponse, rawResponse) {
    var _a;
    const fixApplied = fixInvalidBatchQueryResponse(generatedResponse, rawResponse);
    /* Sort the ids that are passed in with the queries, as numbers instead of strings
     * It is not guaranteed that service will return the responses for queries in the same order
     * as the queries are passed in
     */
    const responseList = generatedResponse.responses || [];
    const newResponse = (_a = responseList === null || responseList === void 0 ? void 0 : responseList.sort((a, b) => {
        let left = 0;
        if (a.id != null) {
            left = parseInt(a.id, 10);
        }
        let right = 0;
        if (b.id != null) {
            right = parseInt(b.id, 10);
        }
        return left - right;
    })) === null || _a === void 0 ? void 0 : _a.map((response) => convertBatchQueryResponseHelper(response));
    newResponse["__fixApplied"] = fixApplied;
    return newResponse;
}
/**
 * This is a workaround for a service bug that we're investigating. The 'body' column will occasionally come
 * back as a JSON string, instead of being a JSON object.
 *
 * (examples, with excess stuff trimmed)
 * Correct: `{"responses":[{"body":{"tables":[{"name":"PrimaryResult","columns":[{"name":"stringcolumn","type":"string"}],"rows":[["hello"]}`
 * Broken: `{"responses":[{"body":"{\"tables\":[{\"name\":\"PrimaryResult\",\"columns\":[{\"name\":\"stringcolumn\",\"type\":\"string\"}],\"rows\":[[\"hello\"]}`
 *
 * Issue here: https://github.com/Azure/azure-sdk-for-js/issues/15688
 *
 * @internal
 */
function fixInvalidBatchQueryResponse(generatedResponse, rawResponse) {
    var _a;
    if (generatedResponse.responses == null) {
        return false;
    }
    let hadToFix = false;
    // the body here is incorrect, deserialize the correct one from the raw response itself.
    const parsedBody = JSON.parse(rawResponse.bodyAsText);
    // fix whichever responses are in this broken state (each query has it's own
    // response, so they're not all always broken)
    for (let i = 0; i < generatedResponse.responses.length; ++i) {
        if (((_a = generatedResponse.responses[i].body) === null || _a === void 0 ? void 0 : _a.error) != null) {
            continue;
        }
        // deserialize the raw response from the service, since we'll need index into it.
        generatedResponse.responses[i].body = parsedBody.responses[i].body;
        hadToFix = true;
    }
    return hadToFix;
}
/**
 * @internal
 */
function convertRequestForMetrics(metricNames, queryMetricsOptions) {
    if (!queryMetricsOptions) {
        return {};
    }
    const { orderBy, aggregations, metricNamespace, timespan, granularity } = queryMetricsOptions, rest = tslib.__rest(queryMetricsOptions, ["orderBy", "aggregations", "metricNamespace", "timespan", "granularity"]);
    const obj = Object.assign({}, rest);
    if (timespan) {
        obj.timespan = convertTimespanToInterval(timespan);
    }
    if (orderBy) {
        obj.orderby = orderBy;
    }
    if (metricNames) {
        obj.metricnames = metricNames.join(",");
    }
    if (aggregations) {
        obj.aggregation = aggregations.join(",");
    }
    if (metricNamespace) {
        obj.metricnamespace = metricNamespace;
    }
    if (granularity) {
        obj.interval = granularity;
    }
    return obj;
}
/**
 * @internal
 */
function convertResponseForMetrics(generatedResponse) {
    const metrics = generatedResponse.value.map((metric) => {
        const metricObject = Object.assign(Object.assign({}, metric), { name: metric.name.value, description: metric.displayDescription, timeseries: metric.timeseries.map((ts) => {
                var _a;
                return ({
                    data: ts.data,
                    metadataValues: (_a = ts.metadatavalues) === null || _a === void 0 ? void 0 : _a.map((mv) => {
                        var _a;
                        return (Object.assign(Object.assign({}, mv), { name: (_a = mv.name) === null || _a === void 0 ? void 0 : _a.value }));
                    }),
                });
            }) });
        delete metricObject.displayDescription;
        return metricObject;
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- eslint doesn't recognize that the extracted variables are prefixed with '_' and are purposefully unused.
    const { resourceregion, value: _ignoredValue, interval, timespan } = generatedResponse, rest = tslib.__rest(generatedResponse, ["resourceregion", "value", "interval", "timespan"]);
    const obj = Object.assign(Object.assign({}, rest), { metrics, timespan: convertIntervalToTimeIntervalObject(timespan) });
    if (resourceregion) {
        obj.resourceRegion = resourceregion;
    }
    if (interval) {
        obj.granularity = interval;
    }
    return createMetricsQueryResult(obj);
}
/**
 * @internal
 */
function convertRequestOptionsForMetricsDefinitions(options) {
    if (!options) {
        return {};
    }
    const { metricNamespace } = options, rest = tslib.__rest(options, ["metricNamespace"]);
    const obj = Object.assign({}, rest);
    if (metricNamespace) {
        obj.metricnamespace = metricNamespace;
    }
    return obj;
}
/**
 * @internal
 */
function convertResponseForMetricsDefinitions(generatedResponse) {
    const definitions = generatedResponse === null || generatedResponse === void 0 ? void 0 : generatedResponse.map((genDef) => {
        const { name, dimensions, displayDescription, metricAvailabilities } = genDef, rest = tslib.__rest(genDef, ["name", "dimensions", "displayDescription", "metricAvailabilities"]);
        const response = Object.assign({}, rest);
        if (displayDescription) {
            response.description = displayDescription;
        }
        if (name === null || name === void 0 ? void 0 : name.value) {
            response.name = name.value;
        }
        const mappedMetricAvailabilities = metricAvailabilities === null || metricAvailabilities === void 0 ? void 0 : metricAvailabilities.map((genMetricAvail) => {
            return {
                granularity: genMetricAvail.timeGrain,
                retention: genMetricAvail.retention,
            };
        });
        if (mappedMetricAvailabilities) {
            response.metricAvailabilities = mappedMetricAvailabilities;
        }
        const mappedDimensions = dimensions === null || dimensions === void 0 ? void 0 : dimensions.map((dim) => dim.value);
        if (mappedDimensions) {
            response.dimensions = mappedDimensions;
        }
        return response;
    });
    return definitions;
}
/**
 * @internal
 */
function convertResponseForMetricNamespaces(generatedResponse) {
    const namespaces = generatedResponse === null || generatedResponse === void 0 ? void 0 : generatedResponse.map((genDef) => {
        const { properties } = genDef, rest = tslib.__rest(genDef, ["properties"]);
        const response = Object.assign({}, rest);
        if (properties) {
            response.metricNamespaceName = properties.metricNamespaceName;
        }
        return response;
    });
    return namespaces;
}
/**
 * @internal
 */
function convertGeneratedTable(table) {
    const dynamicsIndices = [];
    const datesIndices = [];
    // most columns convert on deserialization except for `dynamic` columns (basically JSON objects)
    // and 'datetime' (strings that are ISO8601 formatted dates)
    for (let i = 0; i < table.columns.length; ++i) {
        if (table.columns[i].type === "datetime") {
            datesIndices.push(i);
        }
        else if (table.columns[i].type === "dynamic") {
            dynamicsIndices.push(i);
        }
    }
    return Object.assign(Object.assign({}, table), { rows: table.rows.map((row) => {
            for (const dynamicIndex of dynamicsIndices) {
                try {
                    row[dynamicIndex] = JSON.parse(row[dynamicIndex]);
                }
                catch (_err) {
                    /* leave as is. */
                }
            }
            for (const dateIndex of datesIndices) {
                row[dateIndex] = new Date(row[dateIndex]);
            }
            return row;
        }), columnDescriptors: table.columns });
}
/**
 * @internal
 */
function convertBatchQueryResponseHelper(response) {
    try {
        const parsedResponseBody = JSON.parse(response.body);
        return computeResultType(parsedResponseBody);
    }
    catch (e) {
        if (response.body)
            return computeResultType(response.body);
        else
            return {};
    }
}
function computeResultType(generatedResponse) {
    var _a, _b;
    if (!generatedResponse.error) {
        const result = {
            visualization: generatedResponse.render,
            status: exports.LogsQueryResultStatus.Success,
            statistics: generatedResponse.statistics,
            tables: ((_a = generatedResponse.tables) === null || _a === void 0 ? void 0 : _a.map((table) => convertGeneratedTable(table))) ||
                [],
        };
        return result;
    }
    else {
        if (generatedResponse.tables) {
            const result = {
                visualization: generatedResponse.render,
                status: exports.LogsQueryResultStatus.PartialFailure,
                statistics: generatedResponse.statistics,
                partialTables: (_b = generatedResponse.tables) === null || _b === void 0 ? void 0 : _b.map((table) => convertGeneratedTable(table)),
                partialError: mapError(generatedResponse.error),
            };
            return result;
        }
        else {
            const errorInfo = mapError(generatedResponse.error);
            const result = Object.assign({ status: exports.LogsQueryResultStatus.Failure }, errorInfo);
            return result;
        }
    }
}
function mapError(error) {
    let innermostError = error;
    while (innermostError.innerError) {
        innermostError = innermostError.innerError;
    }
    return {
        name: "Error",
        code: error.code,
        message: `${error.message}.  ${innermostError.message}`,
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
const SDK_VERSION = "1.1.1";

// Copyright (c) Microsoft Corporation.
/**
 * Global tracing client used by this package.
 *
 * @internal
 */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.Monitor",
    packageName: "@azure/monitor-query",
    packageVersion: SDK_VERSION,
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getLogQueryEndpoint(options) {
    if (!options.endpoint) {
        throw new Error("options.endpoint is required");
    }
    const url = new URL(options.endpoint);
    url.pathname = "/v1";
    return url.toString();
}

// Copyright (c) Microsoft Corporation.
const defaultMonitorScope = "https://api.loganalytics.io/.default";
/**
 * Client for Azure Log Analytics
 */
class LogsQueryClient {
    /**
     * Construct a LogsClient that can be used to query logs using the Log Analytics Query language.
     *
     * @param tokenCredential - A token credential.
     * @param options - Options for the LogsClient.
     */
    constructor(tokenCredential, options) {
        var _a;
        // This client defaults to using 'https://api.loganalytics.io/' as the
        // host.
        let scope;
        let endpoint = options === null || options === void 0 ? void 0 : options.endpoint;
        if (options === null || options === void 0 ? void 0 : options.endpoint) {
            scope = `${options.endpoint}/.default`;
            endpoint = getLogQueryEndpoint(options);
        }
        const credentialOptions = {
            credentialScopes: scope,
        };
        const packageDetails = `azsdk-js-monitor-query/${SDK_VERSION}`;
        const userAgentPrefix = (options === null || options === void 0 ? void 0 : options.userAgentOptions) && (options === null || options === void 0 ? void 0 : options.userAgentOptions.userAgentPrefix)
            ? `${options === null || options === void 0 ? void 0 : options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        this._logAnalytics = new AzureLogAnalytics(Object.assign(Object.assign({}, options), { $host: endpoint, endpoint: endpoint, credentialScopes: (_a = credentialOptions === null || credentialOptions === void 0 ? void 0 : credentialOptions.credentialScopes) !== null && _a !== void 0 ? _a : defaultMonitorScope, credential: tokenCredential, userAgentOptions: {
                userAgentPrefix,
            } }));
    }
    /**
     * Queries logs in a Log Analytics Workspace.
     *
     * @param workspaceId - The 'Workspace Id' for the Log Analytics Workspace
     * @param query - A Kusto query.
     * @param timespan - The timespan over which to query data. This is an ISO8601 time period value. This timespan is applied in addition to any that are specified in the query expression.
     *  Some common durations can be found in the `Durations` object.
     * @param options - Options to adjust various aspects of the request.
     * @returns The result of the query.
     */
    async queryWorkspace(workspaceId, query, timespan, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        let timeInterval = "";
        return tracingClient.withSpan("LogsQueryClient.queryWorkspace", options, async (updatedOptions) => {
            if (timespan) {
                timeInterval = convertTimespanToInterval(timespan);
            }
            const { flatResponse, rawResponse } = await getRawResponse((paramOptions) => this._logAnalytics.query.execute(workspaceId, {
                query,
                timespan: timeInterval,
                workspaces: options === null || options === void 0 ? void 0 : options.additionalWorkspaces,
            }, paramOptions), Object.assign(Object.assign({}, updatedOptions), { requestOptions: {
                    customHeaders: Object.assign({}, formatPreferHeader(options)),
                } }));
            const parsedBody = JSON.parse(rawResponse.bodyAsText);
            flatResponse.tables = parsedBody.tables;
            const res = {
                tables: flatResponse.tables.map(convertGeneratedTable),
                statistics: flatResponse.statistics,
                visualization: flatResponse.render,
            };
            if (!flatResponse.error) {
                // if there is no error field, it is success
                const result = {
                    tables: res.tables,
                    statistics: res.statistics,
                    visualization: res.visualization,
                    status: exports.LogsQueryResultStatus.Success,
                };
                return result;
            }
            else {
                const result = {
                    partialTables: res.tables,
                    status: exports.LogsQueryResultStatus.PartialFailure,
                    partialError: mapError(flatResponse.error),
                    statistics: res.statistics,
                    visualization: res.visualization,
                };
                return result;
            }
        });
    }
    /**
     * Query Logs with multiple queries, in a batch.
     * @param batch - A batch of Kusto queries to execute. Each query can be configured to run against separate workspaces.
     * @param options - Options for querying logs in a batch.
     * @returns The Logs query results for all the queries.
     */
    async queryBatch(batch, options = {}) {
        return tracingClient.withSpan("LogsQueryClient.queryBatch", options, async (updatedOptions) => {
            const generatedRequest = convertRequestForQueryBatch(batch);
            const { flatResponse, rawResponse } = await getRawResponse((paramOptions) => this._logAnalytics.query.batch(generatedRequest, paramOptions), updatedOptions || {});
            const result = convertResponseForQueryBatch(flatResponse, rawResponse);
            return result;
        });
    }
    /**
     * Executes a Kusto query on an Azure resource
     *
     * @param resourceId - The identifier of the resource. The expected format is
           '/subscriptions/<sid>/resourceGroups/<rg>/providers/<providerName>/<resourceType>/<resourceName>'.
     * @param query - A Kusto query. Learn more about the `Kusto query syntax <https://docs.microsoft.com/azure/data-explorer/kusto/query/>`.
     * @param timespan - The timespan over which to query data. This is an ISO8601 time period value. This timespan is applied in addition to any that are specified in the query expression.
     *  Some common durations can be found in the {@link Durations} object.
     * @param options - Options to adjust various aspects of the request.
     * @returns Returns all the Azure Monitor logs matching the given Kusto query for an Azure resource.
     */
    async queryResource(resourceId, query, timespan, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        let timeInterval = "";
        return tracingClient.withSpan("LogsQueryClient.queryResource", options, async (updatedOptions) => {
            timeInterval = convertTimespanToInterval(timespan);
            if (resourceId.startsWith("/")) {
                resourceId = resourceId.substring(1);
            }
            const { flatResponse, rawResponse } = await getRawResponse((paramOptions) => this._logAnalytics.query.resourceExecute(resourceId, {
                query,
                timespan: timeInterval,
                workspaces: options === null || options === void 0 ? void 0 : options.additionalWorkspaces,
            }, paramOptions), Object.assign(Object.assign({}, updatedOptions), { requestOptions: {
                    customHeaders: Object.assign({}, formatPreferHeader(options)),
                } }));
            const parsedBody = JSON.parse(rawResponse.bodyAsText);
            flatResponse.tables = parsedBody.tables;
            const res = {
                tables: flatResponse.tables.map(convertGeneratedTable),
                statistics: flatResponse.statistics,
                visualization: flatResponse.render,
            };
            if (!flatResponse.error) {
                // if there is no error field, it is success
                const result = {
                    tables: res.tables,
                    statistics: res.statistics,
                    visualization: res.visualization,
                    status: exports.LogsQueryResultStatus.Success,
                };
                return result;
            }
            else {
                const result = {
                    partialTables: res.tables,
                    status: exports.LogsQueryResultStatus.PartialFailure,
                    partialError: mapError(flatResponse.error),
                    statistics: res.statistics,
                    visualization: res.visualization,
                };
                return result;
            }
        });
    }
}
async function getRawResponse(f, options) {
    // renaming onResponse received from customer to customerProvidedCallback
    const { onResponse: customerProvidedCallback } = options || {};
    let rawResponse = undefined;
    // flatResponseParam - is basically the flatResponse received from service call -
    // just named it so that linter doesn't complain
    // onResponse - includes the rawResponse and the customer's provided onResponse
    const flatResponse = await f(Object.assign(Object.assign({}, options), { onResponse: (response, flatResponseParam) => {
            rawResponse = response;
            customerProvidedCallback === null || customerProvidedCallback === void 0 ? void 0 : customerProvidedCallback(response, flatResponseParam);
        } }));
    return { flatResponse, rawResponse: rawResponse };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ApiVersion201801} that the service accepts. */
var KnownApiVersion201801$1;
(function (KnownApiVersion201801) {
    /** Api Version '2018-01-01' */
    KnownApiVersion201801["TwoThousandEighteen0101"] = "2018-01-01";
})(KnownApiVersion201801$1 || (KnownApiVersion201801$1 = {}));
/** Known values of {@link MetricUnit} that the service accepts. */
var KnownMetricUnit$1;
(function (KnownMetricUnit) {
    KnownMetricUnit["Count"] = "Count";
    KnownMetricUnit["Bytes"] = "Bytes";
    KnownMetricUnit["Seconds"] = "Seconds";
    KnownMetricUnit["CountPerSecond"] = "CountPerSecond";
    KnownMetricUnit["BytesPerSecond"] = "BytesPerSecond";
    KnownMetricUnit["Percent"] = "Percent";
    KnownMetricUnit["MilliSeconds"] = "MilliSeconds";
    KnownMetricUnit["ByteSeconds"] = "ByteSeconds";
    KnownMetricUnit["Unspecified"] = "Unspecified";
    KnownMetricUnit["Cores"] = "Cores";
    KnownMetricUnit["MilliCores"] = "MilliCores";
    KnownMetricUnit["NanoCores"] = "NanoCores";
    KnownMetricUnit["BitsPerSecond"] = "BitsPerSecond";
})(KnownMetricUnit$1 || (KnownMetricUnit$1 = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const Response = {
    type: {
        name: "Composite",
        className: "Response",
        modelProperties: {
            cost: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "cost",
                type: {
                    name: "Number"
                }
            },
            timespan: {
                serializedName: "timespan",
                required: true,
                type: {
                    name: "String"
                }
            },
            interval: {
                serializedName: "interval",
                type: {
                    name: "TimeSpan"
                }
            },
            namespace: {
                serializedName: "namespace",
                type: {
                    name: "String"
                }
            },
            resourceregion: {
                serializedName: "resourceregion",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Metric"
                        }
                    }
                }
            }
        }
    }
};
const Metric = {
    type: {
        name: "Composite",
        className: "Metric",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "LocalizableString"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "errorCode",
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                required: true,
                type: {
                    name: "String"
                }
            },
            timeseries: {
                serializedName: "timeseries",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimeSeriesElement"
                        }
                    }
                }
            }
        }
    }
};
const LocalizableString$1 = {
    type: {
        name: "Composite",
        className: "LocalizableString",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TimeSeriesElement = {
    type: {
        name: "Composite",
        className: "TimeSeriesElement",
        modelProperties: {
            metadatavalues: {
                serializedName: "metadatavalues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataValue"
                        }
                    }
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricValue"
                        }
                    }
                }
            }
        }
    }
};
const MetadataValue = {
    type: {
        name: "Composite",
        className: "MetadataValue",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "LocalizableString"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricValue = {
    type: {
        name: "Composite",
        className: "MetricValue",
        modelProperties: {
            timeStamp: {
                serializedName: "timeStamp",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            average: {
                serializedName: "average",
                type: {
                    name: "Number"
                }
            },
            minimum: {
                serializedName: "minimum",
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                type: {
                    name: "Number"
                }
            },
            total: {
                serializedName: "total",
                type: {
                    name: "Number"
                }
            },
            count: {
                serializedName: "count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ErrorResponse$2 = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Response: Response,
    Metric: Metric,
    LocalizableString: LocalizableString$1,
    TimeSeriesElement: TimeSeriesElement,
    MetadataValue: MetadataValue,
    MetricValue: MetricValue,
    ErrorResponse: ErrorResponse$2
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept$2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host$2 = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceUri$2 = {
    parameterPath: "resourceUri",
    mapper: {
        serializedName: "resourceUri",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const timespan = {
    parameterPath: ["options", "timespan"],
    mapper: {
        serializedName: "timespan",
        type: {
            name: "String"
        }
    }
};
const interval = {
    parameterPath: ["options", "interval"],
    mapper: {
        serializedName: "interval",
        type: {
            name: "TimeSpan"
        }
    }
};
const metricnames = {
    parameterPath: ["options", "metricnames"],
    mapper: {
        serializedName: "metricnames",
        type: {
            name: "String"
        }
    }
};
const aggregation = {
    parameterPath: ["options", "aggregation"],
    mapper: {
        serializedName: "aggregation",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "top",
        type: {
            name: "Number"
        }
    }
};
const orderby = {
    parameterPath: ["options", "orderby"],
    mapper: {
        serializedName: "orderby",
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const resultType = {
    parameterPath: ["options", "resultType"],
    mapper: {
        serializedName: "resultType",
        type: {
            name: "Enum",
            allowedValues: ["Data", "Metadata"]
        }
    }
};
const apiVersion$2 = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const metricnamespace$1 = {
    parameterPath: ["options", "metricnamespace"],
    mapper: {
        serializedName: "metricnamespace",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Metrics operations. */
class MetricsImpl {
    /**
     * Initialize a new instance of the class Metrics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * **Lists the metric values for a resource**.
     * @param resourceUri The identifier of the resource.
     * @param options The options parameters.
     */
    list(resourceUri, options) {
        return this.client.sendOperationRequest({ resourceUri, options }, listOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers$2, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/{resourceUri}/providers/Microsoft.Insights/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Response
        },
        default: {
            bodyMapper: ErrorResponse$2
        }
    },
    queryParameters: [
        timespan,
        interval,
        metricnames,
        aggregation,
        top,
        orderby,
        filter,
        resultType,
        apiVersion$2,
        metricnamespace$1
    ],
    urlParameters: [$host$2, resourceUri$2],
    headerParameters: [accept$2],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class MonitorManagementClientContext$2 extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the MonitorManagementClientContext class.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(apiVersion, options) {
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-monitor-metrics/1.1.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.apiVersion = apiVersion;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class MonitorManagementClient$2 extends MonitorManagementClientContext$2 {
    /**
     * Initializes a new instance of the MonitorManagementClient class.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(apiVersion, options) {
        super(apiVersion, options);
        this.metrics = new MetricsImpl(this);
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ApiVersion201801} that the service accepts. */
var KnownApiVersion201801;
(function (KnownApiVersion201801) {
    /** Api Version '2018-01-01' */
    KnownApiVersion201801["TwoThousandEighteen0101"] = "2018-01-01";
})(KnownApiVersion201801 || (KnownApiVersion201801 = {}));
/** Known values of {@link MetricClass} that the service accepts. */
var KnownMetricClass;
(function (KnownMetricClass) {
    KnownMetricClass["Availability"] = "Availability";
    KnownMetricClass["Transactions"] = "Transactions";
    KnownMetricClass["Errors"] = "Errors";
    KnownMetricClass["Latency"] = "Latency";
    KnownMetricClass["Saturation"] = "Saturation";
})(KnownMetricClass || (KnownMetricClass = {}));
/** Known values of {@link MetricUnit} that the service accepts. */
var KnownMetricUnit;
(function (KnownMetricUnit) {
    KnownMetricUnit["Count"] = "Count";
    KnownMetricUnit["Bytes"] = "Bytes";
    KnownMetricUnit["Seconds"] = "Seconds";
    KnownMetricUnit["CountPerSecond"] = "CountPerSecond";
    KnownMetricUnit["BytesPerSecond"] = "BytesPerSecond";
    KnownMetricUnit["Percent"] = "Percent";
    KnownMetricUnit["MilliSeconds"] = "MilliSeconds";
    KnownMetricUnit["ByteSeconds"] = "ByteSeconds";
    KnownMetricUnit["Unspecified"] = "Unspecified";
    KnownMetricUnit["Cores"] = "Cores";
    KnownMetricUnit["MilliCores"] = "MilliCores";
    KnownMetricUnit["NanoCores"] = "NanoCores";
    KnownMetricUnit["BitsPerSecond"] = "BitsPerSecond";
})(KnownMetricUnit || (KnownMetricUnit = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const MetricDefinitionCollection = {
    type: {
        name: "Composite",
        className: "MetricDefinitionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDefinition"
                        }
                    }
                }
            }
        }
    }
};
const MetricDefinition = {
    type: {
        name: "Composite",
        className: "MetricDefinition",
        modelProperties: {
            isDimensionRequired: {
                serializedName: "isDimensionRequired",
                type: {
                    name: "Boolean"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            namespace: {
                serializedName: "namespace",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "LocalizableString"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            metricClass: {
                serializedName: "metricClass",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            primaryAggregationType: {
                serializedName: "primaryAggregationType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Average",
                        "Count",
                        "Minimum",
                        "Maximum",
                        "Total"
                    ]
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "None",
                                "Average",
                                "Count",
                                "Minimum",
                                "Maximum",
                                "Total"
                            ]
                        }
                    }
                }
            },
            metricAvailabilities: {
                serializedName: "metricAvailabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricAvailability"
                        }
                    }
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LocalizableString"
                        }
                    }
                }
            }
        }
    }
};
const LocalizableString = {
    type: {
        name: "Composite",
        className: "LocalizableString",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricAvailability = {
    type: {
        name: "Composite",
        className: "MetricAvailability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                type: {
                    name: "TimeSpan"
                }
            },
            retention: {
                serializedName: "retention",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const ErrorResponse$1 = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MetricDefinitionCollection: MetricDefinitionCollection,
    MetricDefinition: MetricDefinition,
    LocalizableString: LocalizableString,
    MetricAvailability: MetricAvailability,
    ErrorResponse: ErrorResponse$1
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept$1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host$1 = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceUri$1 = {
    parameterPath: "resourceUri",
    mapper: {
        serializedName: "resourceUri",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion$1 = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const metricnamespace = {
    parameterPath: ["options", "metricnamespace"],
    mapper: {
        serializedName: "metricnamespace",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing MetricDefinitions operations. */
class MetricDefinitionsImpl {
    /**
     * Initialize a new instance of the class MetricDefinitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the metric definitions for the resource.
     * @param resourceUri The identifier of the resource.
     * @param options The options parameters.
     */
    list(resourceUri, options) {
        return this.client.sendOperationRequest({ resourceUri, options }, listOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers$1, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/{resourceUri}/providers/Microsoft.Insights/metricDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricDefinitionCollection
        },
        default: {
            bodyMapper: ErrorResponse$1
        }
    },
    queryParameters: [apiVersion$1, metricnamespace],
    urlParameters: [$host$1, resourceUri$1],
    headerParameters: [accept$1],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class MonitorManagementClientContext$1 extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the MonitorManagementClientContext class.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(apiVersion, options) {
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-monitor-metrics-definitions/1.1.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.apiVersion = apiVersion;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class MonitorManagementClient$1 extends MonitorManagementClientContext$1 {
    /**
     * Initializes a new instance of the MonitorManagementClient class.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(apiVersion, options) {
        super(apiVersion, options);
        this.metricDefinitions = new MetricDefinitionsImpl(this);
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ApiVersion20171201Preview} that the service accepts. */
var KnownApiVersion20171201Preview;
(function (KnownApiVersion20171201Preview) {
    /** Api Version '2017-12-01-preview' */
    KnownApiVersion20171201Preview["TwoThousandSeventeen1201Preview"] = "2017-12-01-preview";
})(KnownApiVersion20171201Preview || (KnownApiVersion20171201Preview = {}));
/** Known values of {@link NamespaceClassification} that the service accepts. */
var KnownNamespaceClassification;
(function (KnownNamespaceClassification) {
    KnownNamespaceClassification["Platform"] = "Platform";
    KnownNamespaceClassification["Custom"] = "Custom";
    KnownNamespaceClassification["Qos"] = "Qos";
})(KnownNamespaceClassification || (KnownNamespaceClassification = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const MetricNamespaceCollection = {
    type: {
        name: "Composite",
        className: "MetricNamespaceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricNamespace"
                        }
                    }
                }
            }
        }
    }
};
const MetricNamespace = {
    type: {
        name: "Composite",
        className: "MetricNamespace",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            classification: {
                serializedName: "classification",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "MetricNamespaceName"
                }
            }
        }
    }
};
const MetricNamespaceName = {
    type: {
        name: "Composite",
        className: "MetricNamespaceName",
        modelProperties: {
            metricNamespaceName: {
                serializedName: "metricNamespaceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MetricNamespaceCollection: MetricNamespaceCollection,
    MetricNamespace: MetricNamespace,
    MetricNamespaceName: MetricNamespaceName,
    ErrorResponse: ErrorResponse
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceUri = {
    parameterPath: "resourceUri",
    mapper: {
        serializedName: "resourceUri",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const startTime = {
    parameterPath: ["options", "startTime"],
    mapper: {
        serializedName: "startTime",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing MetricNamespaces operations. */
class MetricNamespacesImpl {
    /**
     * Initialize a new instance of the class MetricNamespaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the metric namespaces for the resource.
     * @param resourceUri The identifier of the resource.
     * @param options The options parameters.
     */
    list(resourceUri, options) {
        return this.client.sendOperationRequest({ resourceUri, options }, listOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/{resourceUri}/providers/microsoft.insights/metricNamespaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricNamespaceCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, startTime],
    urlParameters: [$host, resourceUri],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class MonitorManagementClientContext extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the MonitorManagementClientContext class.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(apiVersion, options) {
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-monitor-metrics-namespaces/1.1.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.apiVersion = apiVersion;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class MonitorManagementClient extends MonitorManagementClientContext {
    /**
     * Initializes a new instance of the MonitorManagementClient class.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(apiVersion, options) {
        super(apiVersion, options);
        this.metricNamespaces = new MetricNamespacesImpl(this);
    }
}

const defaultMetricsScope = "https://management.azure.com/.default";
/**
 * A client that can query metrics, get metric definitions and get metric namespaces.
 */
class MetricsQueryClient {
    /**
     * Creates a MetricsQueryClient.
     * @param tokenCredential - A TokenCredential that has rights to query metrics on resources.
     * @param options - Options for the client like controlling request retries.
     */
    constructor(tokenCredential, options) {
        var _a;
        let scope;
        if (options === null || options === void 0 ? void 0 : options.endpoint) {
            scope = `${options === null || options === void 0 ? void 0 : options.endpoint}/.default`;
        }
        const credentialOptions = {
            credentialScopes: scope,
        };
        const packageDetails = `azsdk-js-monitor-query/${SDK_VERSION}`;
        const userAgentPrefix = (options === null || options === void 0 ? void 0 : options.userAgentOptions) && (options === null || options === void 0 ? void 0 : options.userAgentOptions.userAgentPrefix)
            ? `${options === null || options === void 0 ? void 0 : options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const serviceClientOptions = Object.assign(Object.assign({}, options), { $host: options === null || options === void 0 ? void 0 : options.endpoint, endpoint: options === null || options === void 0 ? void 0 : options.endpoint, credentialScopes: (_a = credentialOptions === null || credentialOptions === void 0 ? void 0 : credentialOptions.credentialScopes) !== null && _a !== void 0 ? _a : defaultMetricsScope, credential: tokenCredential, userAgentOptions: {
                userAgentPrefix,
            } });
        this._metricsClient = new MonitorManagementClient$2(KnownApiVersion201801$1.TwoThousandEighteen0101, serviceClientOptions);
        this._definitionsClient = new MonitorManagementClient$1(KnownApiVersion201801.TwoThousandEighteen0101, serviceClientOptions);
        this._namespacesClient = new MonitorManagementClient(KnownApiVersion20171201Preview.TwoThousandSeventeen1201Preview, serviceClientOptions);
    }
    /**
     * Query metrics, given a resource URI
     * @param resourceUri - The resource URI to query.
     * @param metricNames - The names of the metrics to retrieve.
     * @param options - Options for querying metrics.
     * @returns A response containing metrics.
     */
    async queryResource(resourceUri, metricNames, options = {} // eslint-disable-line @azure/azure-sdk/ts-naming-options
    ) {
        return tracingClient.withSpan("MetricsQueryClient.queryResource", options, async (updatedOptions) => {
            const response = await this._metricsClient.metrics.list(resourceUri, convertRequestForMetrics(metricNames, updatedOptions));
            return convertResponseForMetrics(response);
        });
    }
    /**
     * List alert segments for Metric Definitions
     */
    listSegmentOfMetricDefinitions(resourceUri, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSegmentOfMetricDefinitions_1() {
            const segmentResponse = yield tslib.__await(tracingClient.withSpan("MetricsQueryClient.listSegmentOfMetricDefinitions", options, async (updatedOptions) => this._definitionsClient.metricDefinitions.list(resourceUri, convertRequestOptionsForMetricsDefinitions(updatedOptions))));
            yield yield tslib.__await(convertResponseForMetricsDefinitions(segmentResponse.value));
        });
    }
    /**
     * List items for Metric Definitions
     */
    listItemsOfMetricDefinitions(resourceUri, options) {
        return tslib.__asyncGenerator(this, arguments, function* listItemsOfMetricDefinitions_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSegmentOfMetricDefinitions(resourceUri, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const segment = _c;
                        if (segment) {
                            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                        }
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     *   /**
     *
     * Returns an async iterable iterator to list metric definitions.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * const metricsQueryClient = new MetricsQueryClient(tokenCredential);
     * const metricDefinitions = client.listMetricDefinitions(resourceUri, options);
     * let i = 1;
     * for await (const metricDefinition of metricDefinitions) {
     *   console.log(`metricDefinition ${i++}:`);
     *   console.log(metricDefinition);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let iter = client.listMetricDefinitions(resourceUri, options);
     * let result = await iter.next();
     * while (!result.done) {
     *   console.log(` metricDefinitions - ${result.value.id}, ${result.value.name}`);
     *   result = await iter.next();
     * }
     * ```
     *
     * Get a list of metric definitions, given a resource URI.
     * @param resourceUri - The resource URI to get metric definitions for.
     * @param options - Options for getting metric definitions.
     * @returns Metric definitions for a given resource URI.
     */
    listMetricDefinitions(resourceUri, options) {
        const iter = this.listItemsOfMetricDefinitions(resourceUri, options);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @returns an AsyncIterableIterator that works a page at a time
             */
            byPage: () => {
                return this.listSegmentOfMetricDefinitions(resourceUri, options);
            },
        };
    }
    /**
     * List alert segments for Metric Namespaces
     */
    listSegmentOfMetricNamespaces(resourceUri, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSegmentOfMetricNamespaces_1() {
            const segmentResponse = yield tslib.__await(tracingClient.withSpan("MetricsQueryClient.listSegmentOfMetricNamespaces", options, async (updatedOptions) => this._namespacesClient.metricNamespaces.list(resourceUri, updatedOptions)));
            yield yield tslib.__await(convertResponseForMetricNamespaces(segmentResponse.value));
        });
    }
    /**
     * List items for Metric Namespaces
     */
    listItemsOfMetricNamespaces(resourceUri, options) {
        return tslib.__asyncGenerator(this, arguments, function* listItemsOfMetricNamespaces_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSegmentOfMetricNamespaces(resourceUri, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const segment = _c;
                        if (segment) {
                            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment)));
                        }
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     *
     * Returns an async iterable iterator to list metric namespaces.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * const metricsQueryClient = new MetricsQueryClient(tokenCredential);
     * const metricNamespaces = client.listMetricNamespaces(resourceUri, options);
     * let i = 1;
     * for await (const metricNamespace of metricNamespaces) {
     *   console.log(`metricNamespace ${i++}:`);
     *   console.log(metricNamespace);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let iter = client.listMetricNamespaces(resourceUri, options);
     * let result = await iter.next();
     * while (!result.done) {
     *   console.log(` metricNamespace - ${result.value.id}, ${result.value.name}`);
     *   result = await iter.next();
     * }
     * ```
     * Get a list of metric namespaces, given a resource URI.
     * @param resourceUri - The resource URI to get metric namespaces for.
     * @param options - Options for getting metric namespaces.
     * @returns Metric namespaces for a given resource URI.
     */
    listMetricNamespaces(resourceUri, options) {
        const iter = this.listItemsOfMetricNamespaces(resourceUri, options);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * @returns an AsyncIterableIterator that works a page at a time
             */
            byPage: () => {
                return this.listSegmentOfMetricNamespaces(resourceUri, options);
            },
        };
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Aliases for some common ISO8601 durations.
 */
const Durations = {
    /** Alias for ISO8601 value 'P7D' */
    sevenDays: "P7D",
    /** Alias for ISO8601 value 'P3D' */
    threeDays: "P3D",
    /** Alias for ISO8601 value 'P2D' */
    twoDays: "P2D",
    /** Alias for ISO8601 value 'P1D' */
    oneDay: "P1D",
    /** Alias for ISO8601 value 'PT1H' */
    oneHour: "PT1H",
    /** Alias for ISO8601 value 'PT4H' */
    fourHours: "PT4H",
    /** Alias for ISO8601 value 'PT24H' */
    twentyFourHours: "PT24H",
    /** Alias for ISO8601 value 'PT48H' */
    fortyEightHours: "PT48H",
    /**
     * @deprecated Alias name `fourtyEightHours` for ISO8601 value 'PT48H' is deprecated
     */
    fourtyEightHours: "PT48H",
    /** Alias for ISO8601 value 'PT30M' */
    thirtyMinutes: "PT30M",
    /** Alias for ISO8601 value 'PT5M' */
    fiveMinutes: "PT5M",
};

exports.Durations = Durations;
exports.LogsQueryClient = LogsQueryClient;
exports.MetricsQueryClient = MetricsQueryClient;
//# sourceMappingURL=index.js.map
